---
title: 0820
category: til-2025年-8月-week4
categoryPath: til\2025年\8月\week4
date: '2025-08-20'
---
# 0820  
## 프로그래머스 과제  
### [결제 서비스에서 발생한 의존성 사이클 문제 해결하기](https://school.programmers.co.kr/skill_check_assignments/694)  
#### 순환 의존성이란?  
- 두 개 이상의 모듈이 서로를 직접 참조하고 있는 상태  
- OrderService -> PaymentService 호출  
- PaymentService -> OrderService 호출  
- 이 때 발생하는 문제점  
	- 서비스간의 결합도가 높아진다.  
	- 결합도가 높아지면 코드를 확장/유지보수할 때 OrderService를 고치려면 PaymentService도 함께 영향을 받기에 결합도를 낮춰야 한다.  
	- 모듈의 로딩 순서가 꼬일 수 있다.  
#### Mediator 패턴이란?  
- 객체들간의 의존성을 없애고 Mediator(중재자) 객체를 두어 객체 간의 상호작용을 중앙에서 관리하는 패턴  
- 왜 필요한가?  
	- 앞에서 발생한 순환 의존성 문제를 해결하기 위한 방법 中 하나  
	- 모듈 간의 결합도를 낮추고 객체간 종속성을 줄일 수 있다.  
- 단점은 없나?  
	- 여러 모듈의 관련 코드가 Mediator로 오기에 Mediator 코드가 방대해질 수 있다.  
- 이와 비슷한 것: Observer(관찰자) Pattern  
	- Observer VS Mediator 차이점  
	- Observer pattern은 단방향. observer가 관찰자니까  
	- 반대로 Mediator pattern은 양방향.  
	- <img src="/images/til/2025年/8月/week4/Pasted image 20250820081733.png" alt="Pasted image 20250820081733" width="400">  
- https://limjs-dev.tistory.com/125  
#### 다른 해결 방법  
##### callback  
- OrderService에 콜백함수를 줘서 의존성을 역전시켜버리는 것  
- 이러면 단방향으로 참조되기에 의존성이 사라짐  
```ts  
export const OrderService = {  
  createOrder: (userId: number, amount: number, onPaid: () => void) => {  
    console.log(`✅ 주문 생성 완료: ${amount}원`);  
    onPaid();  
  },  
};

OrderService.createOrder(userId, amount, () => {  
  PaymentService.processPayment(userId, amount);  
  OrderService.confirmOrder(userId);  
});  
```  
- https://eunjin3786.tistory.com/534

### 그 외  
- 게시물 레이아웃 재구성하기  
	- sort 함수 (prev, next)  
		- sort 메서드는 유니코드를 기준으로 정렬되고, 원본 배열 자체가 정렬된다.  
		- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort  
- todo list 기능 구현 과제

- 테스트 코드가 존재한다면 테스트 코드에 적혀있는 DOM 요소 참조하고 작성하기
