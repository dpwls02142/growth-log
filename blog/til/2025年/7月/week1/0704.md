---
title: '0704'
category: til-2025年-7月-week1
categoryPath: til\2025年\7月\week1
date: '2025-07-04'
---
# 0704  
코테를 위해 책상 주위에 있는 물품들을 다 치웠다........   
시험 당일에 갑자기 치우라고 하면 당황탈거 같아서 ㅠ  
미리 다 치워놓음. 미니멀리스트가 된 기분임

내일은 부캠 코테 월욜은 기업 코테 아자아자!!!  
일단 보는 것에 의의를 두자

<mark>선택에 후회하지 말고 선택한 것에 최선을 다하자</mark>  
앞으로 제 좌우명입니다

<img src="https://i.pinimg.com/736x/3a/30/99/3a309946809c66c3913191e0004a580d.jpg" width="150">

## 코테  
- [백준: 학생번호](https://www.acmicpc.net/problem/1235)  
	- 반복문을 앞에서부터 돌되 인덱스에 -를 붙여서 리스트는 맨 마지막 요소부터 순회하도록함  
	- `[-i:]` -i부터 끝까지 돌아서 매번 set에다가 넣고  
	- 해당 set이 학생 수와 같으면 i를 출력함  
- [백준: 로봇 청소기](https://www.acmicpc.net/problem/14503)  
	- bfs나 dfs는 끝까지 돌아야될때 쓰는거고  
	- 얘는 중간에 벽 만나면 바로 멈추는거니까 그냥 시뮬  
## RealWorld  
원래는 article을 favorite할 때만 tanstack query을 사용했는데  
그러면 article 조회를 할 때 swr을 쓰고 있는데   
둘의 캐싱 키값이 맞지 않아 mutate가 제대로 안 이뤄지고 있었음

이러면 favorite에서 tanstack을 사용하고 있다고 할 수가 없는 것 같아서  
article을 조회할때도 tanstack을 쓰도록 변경함

swr 썼다가 tanstack 썼다가 swr 썼다가 해보니까  
확실히 여러 캐시를 조회 말고 mutate할 때 관리하려면  
swr말고 tanstack을 사용하면 코드 깊이가 얕아져서 읽을 때 편한듯...

월요일에 시험 끝나면 api랑 유틸 나눈거 좀 더 생각해보기

## 기초 지식  
### OSI 7계층  
- 응용: 응용 프로그램 간의 데이터 송수신, HTTP, SMTP(Simple Mail Transfer Protocol)  
	- 응용 프로그램은 크롬이나 웨일 같은 거고,  
	- <mark>응용 계층에서 응용 프로그램의 프로토콜이 사용되니까 </mark>이 계층에 해당하는건 HTTP와 SMTP가 있는거임.  
- 표현: 응용계층/세션계층에서 받은 데이터를 세션계층/응용계층에게 보내기 위해 적당한 형태로 변환  
- 세션: 응용 프로그램 간의 대화 제어 담당  
- 전송: TCP, UDP  
- 네트워크: IP(Internet Protocol), ICMP(Internet Control Message Protocol)와 같이 데이터 전송을 위한 주소 지정  
- 데이터 링크: 물리적 연결에서의 연결 설정, 유지 및 종료  
	- 데이터 통신 회선 접속 -> 데이터 링크 설정(확립) -> 정보 메시지 전송 -> 데이터 링크 종결 -> 데이터 통신 회선 절단  
- 물리: 전송에 필요한 두 장치 간의 실제 접속

- 데이터링크와 세션계층 모두 연결과 대화 흐름을 관리한다는 점에서 동일하지만 <mark>데이터 링크는 네트워크를 관리</mark>하는거고 <mark>세션계층은 응용계층에서의 대화를 관리</mark>.  
### JS 컴파일 원리  
- JS 코드는 고오급 언어이기 때문에 컴퓨터가 바로 못 알아들음.  
- 고로 고오급 언어를 저급언어로 변환해줘야됨.  
- 이 때 사용되는게 AST(추상구문트리)며 이걸로 바이트코드가 만들어짐.  
- <mark>바이트코드를 인터프리터로 실행할 때 런타임 원리가 활용</mark>됨.  
- 그러고 JIT 컴파일이 자주 사용되는 함수들은 머신코드로 최적화함.

### JS 동작(런타임) 원리  
- 싱글 스레드  
	- 스택에는 코드를 순차적으로 넣어놓고 한 번에 하나의 코드만 실행.  
	- 큐에는 비동기 작업(setTimeout, 이벤트 등)의 콜백 함수들을 대기 시켜 놓음.   
		- 콜백이란 말 그대로 Call Back. 나중에 호출될 함수.  
		- 근데 콜백이 무한히 쌓이면 코드 depth가 엄청 깊어지잖음? 이를 콜백헬이라고 부르고  
		- 그래서 나온게 <mark>promise</mark>. 왜 promise냐 하면 나중에 실행될거를 약속하기 때문에 프로미스인거임. (약속해죠~)  
	- 이벤트 루프로 스택이 비어있을 때 큐에서 콜백을 갖고와서 실행함. 즉 큐는 스택이 비어있을 때만 실행.  
	- 힙에는 객체를 저장함.  
- 그럼 <mark>async/await도 큐에 저장</mark>되는가?  
	- ㄴㄴ.  
	- async 자체는 일반 함수처럼 스택에 저장되어 실행됨.  
	- 그러다 await를 만나면 함수 실행이 일시 중단되며 나머지 Promise 코드가 <mark>"마이크로태스크로 큐"</mark>에 들어감  
		- 엥 마이크로태스크 큐는 또 뭐임?  
		- 엄밀히 말하면, 큐에는  
			- 마이크로태스크 큐  
			- 매크로태스크 큐  
		- 가 있음. 마이크로태스크가 매크로보다 우선순위가 높아서 얘를 먼저 비워야됨.